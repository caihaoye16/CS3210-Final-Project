Question 1. Assuming that the following JOS kernel code is correct, what type should variable x have, uintptr_t or physaddr_t?

    mystery_t x;
    char* value = return_a_pointer();
    *value = 10;
    x = (mystery_t) value;

Answer 1.
Variable x should have type uintptr_t.

x is assigned a cast of value. value is a pointer. A pointer has
a value equal to the virtual address of the data it points to. 
So x is assigned a virtual address, and therefore should have
type uintptr_t.


Question 3. (From Lecture 3) We have placed the kernel and user environment in the same address space. Why will user programs not be able to read or write the kernel's memory? What specific mechanisms protect the kernel memory?

Answer 3.
User programs will not be able to read or write the kernel's memory
because the combination of the hardware and the page table will prevent this.
The CPL bits on %cs indicate whether the process is in user or kernel
mode, and each of the page table entries (as well as each of the page
directory entries) has a user bit. If the process is in user mode and
the program tries to access kernel memory, the hardware will not allow
this while the PTE user bit is unset. And since the only way to
dereference physical addresses is through the hardware, it will be
impossible for the user program to get at the kernel's memory.


Question 4. What is the maximum amount of physical memory that this operating system can support? Why?

Answer 4.
With the page table structure we currently have (1 PD with 1023 PDEs;
each PT with 1024 PTE; each page with 4KB), this operating system could
support up to
(1 PD)*(1023 PDEs / PD)*(1 PT / PDE)*(1024 PTEs / PT)*(1 page / PTE)*(4 KB / page)
 = 4,190,208 KB = 4.19 GB.
(the PD has a PDE that points to itself, which is why I only counted
1023 distinct PDEs instead of 1024).


Question 5. How much space overhead is there for managing memory, if we actually had the maximum amount of physical memory? How is this overhead broken down?

Answer 5.
When using the maximum capacity of the paging hardware, there would be
1024 distinct PTs (including the PD). Each of these PTs consists of
1024 32-bit PTEs. This totals 4.194 MB of overhead. 
Technically, the overhead would be more than this, since it also takes
space to store the free page data structure.


Question 6. Revisit the page table setup in kern/entry.S and kern/entrypgdir.c. Immediately after we turn on paging, EIP is still a low number (a little over 1MB). At what point do we transition to running at an EIP above KERNBASE? What makes it possible for us to continue executing at a low EIP between when we enable paging and when we begin running at an EIP above KERNBASE? Why is this transition necessary?

Answer 6.
We transition to running at an EIP above KERNBASE at kern/entry.S:68,
with the jmp to <relocated>.
/kern/entrypgdir.c defines the initial PD and PT that are used in kern/entry.S
and all the code that is run before the real paging system is set up.
This paging systems maps both the [0, 4MB) and [KERNBASE, KERNBASE+4MB)
sets of VAs to the [0, 4MB) set of PAs. 
So after paging is enabled, the low virtual addresses are still being
mapped to the correct low physical addresses.
The transition is necessary so that the kernel can map low virtual addresses
to user code, and so that it can start setting up the rest of memory.


Challenge!
I implemented the 2nd challenge problem: extending the JOS monitor
with memory commands.

The first monitor command shows information about all mappings in a range. 
The first thing it does is error-check the user input, and initialize some data
if it is in the correct format. The beginning of the range is rounded down
to the nearest page boundary, and the end of the range is rounded up. 
Then, for each page boundary in the inclusive range, we attempt to walk the page directory
to the associated PTE. If this operation is successful, 
we print the high-order bits of the physical addresses this page maps to, 
as well as information stored in the permissions and other low-order bits
of the PTE. 
Here, I chose to represent present bits with the associated letter 
(for example, 'U' if the PTE_U bit is present), and an absence of bits with hyphens. 
My function also periodically prints a header, so that anyone reading
the console knows what data is what.

The second monitor command allows the changing of permissions. 
The problem statement here was a bit vague, so I assumed that I should deal with 
user and write permissions only. Again, the function starts by error-checking the input, 
and then initializing some data. 
The user must pass a virtual address, which we use to walk the PD and find the 
associated PTE. 
Based on the format of the user input, the function will either leave the permissions
as-is, or will change them to values specified in the input. 
It does this with a number of bit manipulations, so that all the other data in the 
PTE is untouched. I also call the previous monitor command I wrote, so that
the user can see the old and new permissions.

The third and last monitor function dumps memory data in a given range. 
The address range is assumed to be virtual, though the user can pass a flag
to tell the program to assume they are physical addresses. 
We find the pages associated with the addresses in the range, and iterate through them.
We skip pages that aren't in use.
In a particular page, we iterate through all virtual addresses, and print all the 
dereferenced addresses. 
The output is formatted such that four 32-bit integers of memory are printed per line,
along with the address (either virtual or physical) to the start of that block of four integers.
Also, at the very beginning and very end of iteration, we make sure to start and stop
at the user-provided addresses, rather than the page aligned addresses.
