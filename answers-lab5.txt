Question 1. Do you have to do anything else to ensure that this I/O privilege setting is saved and restored properly when you subsequently switch from one environment to another? Why?

Answer 1.

No, we do not have to do anything else.
When a trap occurs and control switches from user mode to kernel mode, the states of all registers, including the EFLAGS register, are saved into the environment's Trapframe.In particular, the x86 hardware is actually responsible for automatically pushing EFLAGS onto the stack when it receives an exception or an interrupt.
Since the original EFLAGS value had the IOPL bits set properly, the stored value will also have the IOPL bits set properly.
Similarly, when returning control to this environment, all of the saved register states in the Trapframe, including that of EFLAGS, are stored back into the physical registers.
In this case, it is the iret instruction that is responsible for restoring the EFLAGS register.
Again, since the stored value of EFLAGS had the IOPL bits set properly, the restored value will have the IOPL bits set properly.

The IOPL bits will also be properly restored in the event that the FS environment's user exception handler is triggered.
Except this time, the restoration is handled manually with a popfl instruction 
in _pgfault_upcall in lib/pfentry.S.


Question 2. How long approximately did it take you to do this lab?

Answer 2.

I completed the non-challenge part of the lab within a (non-contiguous) span of four hours.
However, ignoring the time I spend distracted by other things, and only counting time I spent coding or thinking about the exercises, I believe I spent less than two hours on it.


Question 3. We simplified the file system this year with the goal of making more time for the final project. Do you feel like you gained a basic understanding of the file I/O in JOS? Feel free to suggest things we could improve.

Answer 3.

I gained a very basic understanding of the file I/O.
However, since we haven't done that much with it, I feel I don't have a great understanding of it.
All of the hard parts of lab 5 were already done for us, and each exercise only required a couple of very simple lines of code, which means I didn't need to understand anything about files to do the lab.
Also, we talked about disks and file I/O many weeks before we got to these topics in the lab, at a time when the labs were on completely different material, so I was less motivated to fully understand files at that time.

I'm not sure that I have any suggestions for improvement.
Although I would've liked a slightly more challenging and interesting lab 5 (I think it would've been really cool to implement parts of the file I/O and the shell ourselves), I understand that it is to our benefit to have a full month, rather than a few weeks, to do the final project.

And having an easy lab 5 was definitely a nice blessing during this busy time of the year.
